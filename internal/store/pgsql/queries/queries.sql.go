// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: queries.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteModule = `-- name: DeleteModule :exec
DELETE
FROM modules
WHERE urn = $1
`

func (q *Queries) DeleteModule(ctx context.Context, urn string) error {
	_, err := q.db.Exec(ctx, deleteModule, urn)
	return err
}

const deleteResourceByURN = `-- name: DeleteResourceByURN :exec
DELETE
FROM resources
WHERE urn = $1
`

func (q *Queries) DeleteResourceByURN(ctx context.Context, urn string) error {
	_, err := q.db.Exec(ctx, deleteResourceByURN, urn)
	return err
}

const deleteResourceDependenciesByURN = `-- name: DeleteResourceDependenciesByURN :exec
DELETE
FROM resource_dependencies
WHERE resource_id = (SELECT id FROM resources WHERE urn = $1)
`

func (q *Queries) DeleteResourceDependenciesByURN(ctx context.Context, urn string) error {
	_, err := q.db.Exec(ctx, deleteResourceDependenciesByURN, urn)
	return err
}

const deleteResourceTagsByURN = `-- name: DeleteResourceTagsByURN :exec
DELETE
FROM resource_tags
WHERE resource_id = (SELECT id FROM resources WHERE urn = $1)
`

func (q *Queries) DeleteResourceTagsByURN(ctx context.Context, urn string) error {
	_, err := q.db.Exec(ctx, deleteResourceTagsByURN, urn)
	return err
}

const getModuleByURN = `-- name: GetModuleByURN :one
SELECT urn, name, project, configs, created_at, updated_at
FROM modules
WHERE urn = $1
`

func (q *Queries) GetModuleByURN(ctx context.Context, urn string) (Module, error) {
	row := q.db.QueryRow(ctx, getModuleByURN, urn)
	var i Module
	err := row.Scan(
		&i.Urn,
		&i.Name,
		&i.Project,
		&i.Configs,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getResourceByURN = `-- name: GetResourceByURN :one
SELECT r.id, r.urn, r.kind, r.name, r.project, r.created_at, r.updated_at, r.spec_configs, r.state_status, r.state_output, r.state_module_data, r.state_next_sync, r.state_sync_result, r.created_by, r.updated_by,
       array_agg(rt.tag)::text[] AS tags,
       (CASE
            WHEN COUNT(rd.dependency_key) > 0 THEN
                json_object_agg(rd.dependency_key, d.urn)
            ELSE
                '{}'::json
           END)                  AS dependencies
FROM resources r
         LEFT JOIN resource_tags rt ON r.id = rt.resource_id
         LEFT JOIN resource_dependencies rd ON r.id = rd.resource_id
         LEFT JOIN resources d ON rd.depends_on = d.id
WHERE r.urn = $1
GROUP BY r.id
`

type GetResourceByURNRow struct {
	ID              int64
	Urn             string
	Kind            string
	Name            string
	Project         string
	CreatedAt       pgtype.Timestamptz
	UpdatedAt       pgtype.Timestamptz
	SpecConfigs     []byte
	StateStatus     string
	StateOutput     []byte
	StateModuleData []byte
	StateNextSync   pgtype.Timestamptz
	StateSyncResult []byte
	CreatedBy       string
	UpdatedBy       string
	Tags            []string
	Dependencies    []byte
}

func (q *Queries) GetResourceByURN(ctx context.Context, urn string) (GetResourceByURNRow, error) {
	row := q.db.QueryRow(ctx, getResourceByURN, urn)
	var i GetResourceByURNRow
	err := row.Scan(
		&i.ID,
		&i.Urn,
		&i.Kind,
		&i.Name,
		&i.Project,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SpecConfigs,
		&i.StateStatus,
		&i.StateOutput,
		&i.StateModuleData,
		&i.StateNextSync,
		&i.StateSyncResult,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.Tags,
		&i.Dependencies,
	)
	return i, err
}

const getResourceDependencies = `-- name: GetResourceDependencies :one
SELECT (CASE
            WHEN COUNT(rd.dependency_key) > 0 THEN
                json_object_agg(rd.dependency_key, d.urn)
            ELSE
                '{}'::json
    END) AS dependencies
FROM resources r
         LEFT JOIN resource_dependencies rd ON r.id = rd.resource_id
         LEFT JOIN resources d ON rd.depends_on = d.id
WHERE r.urn = $1
GROUP BY r.id
`

func (q *Queries) GetResourceDependencies(ctx context.Context, urn string) ([]byte, error) {
	row := q.db.QueryRow(ctx, getResourceDependencies, urn)
	var dependencies []byte
	err := row.Scan(&dependencies)
	return dependencies, err
}

const insertModule = `-- name: InsertModule :exec
INSERT INTO modules (urn, project, name, configs)
VALUES ($1, $2, $3, $4)
`

type InsertModuleParams struct {
	Urn     string
	Project string
	Name    string
	Configs []byte
}

func (q *Queries) InsertModule(ctx context.Context, arg InsertModuleParams) error {
	_, err := q.db.Exec(ctx, insertModule,
		arg.Urn,
		arg.Project,
		arg.Name,
		arg.Configs,
	)
	return err
}

const insertResource = `-- name: InsertResource :one
INSERT INTO resources ("urn", "kind", "project", "name", "created_at", "updated_at", "created_by", "updated_by",
                       "spec_configs", "state_status", "state_output", "state_module_data",
                       "state_next_sync", "state_sync_result")
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
RETURNING id
`

type InsertResourceParams struct {
	Urn             string
	Kind            string
	Project         string
	Name            string
	CreatedAt       pgtype.Timestamptz
	UpdatedAt       pgtype.Timestamptz
	CreatedBy       string
	UpdatedBy       string
	SpecConfigs     []byte
	StateStatus     string
	StateOutput     []byte
	StateModuleData []byte
	StateNextSync   pgtype.Timestamptz
	StateSyncResult []byte
}

func (q *Queries) InsertResource(ctx context.Context, arg InsertResourceParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertResource,
		arg.Urn,
		arg.Kind,
		arg.Project,
		arg.Name,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.CreatedBy,
		arg.UpdatedBy,
		arg.SpecConfigs,
		arg.StateStatus,
		arg.StateOutput,
		arg.StateModuleData,
		arg.StateNextSync,
		arg.StateSyncResult,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertResourceDependency = `-- name: InsertResourceDependency :exec
INSERT INTO resource_dependencies (resource_id, dependency_key, depends_on)
VALUES ($1, $2, (SELECT id FROM resources WHERE urn = $3))
`

type InsertResourceDependencyParams struct {
	ResourceID    int64
	DependencyKey string
	Urn           string
}

func (q *Queries) InsertResourceDependency(ctx context.Context, arg InsertResourceDependencyParams) error {
	_, err := q.db.Exec(ctx, insertResourceDependency, arg.ResourceID, arg.DependencyKey, arg.Urn)
	return err
}

type InsertResourceTagsParams struct {
	ResourceID int64
	Tag        string
}

const insertRevision = `-- name: InsertRevision :exec
INSERT INTO revisions ("resource_id", "reason", "spec_configs", "created_by")
VALUES ($1, $2, $3, $4)
`

type InsertRevisionParams struct {
	ResourceID  int64
	Reason      string
	SpecConfigs []byte
	CreatedBy   string
}

func (q *Queries) InsertRevision(ctx context.Context, arg InsertRevisionParams) error {
	_, err := q.db.Exec(ctx, insertRevision,
		arg.ResourceID,
		arg.Reason,
		arg.SpecConfigs,
		arg.CreatedBy,
	)
	return err
}

const listAllModulesForProject = `-- name: ListAllModulesForProject :many
SELECT urn, name, project, configs, created_at, updated_at
FROM modules
WHERE project = $1
`

func (q *Queries) ListAllModulesForProject(ctx context.Context, project string) ([]Module, error) {
	rows, err := q.db.Query(ctx, listAllModulesForProject, project)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Module
	for rows.Next() {
		var i Module
		if err := rows.Scan(
			&i.Urn,
			&i.Name,
			&i.Project,
			&i.Configs,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listResourceRevisions = `-- name: ListResourceRevisions :many
SELECT rev.id, rev.reason, rev.created_at, rev.resource_id, rev.spec_configs, rev.created_by, array_agg(distinct rt.tag)::text[] AS tags
FROM resources r
         JOIN revisions rev ON r.id = rev.resource_id
         JOIN revision_tags rt ON rev.id = rt.revision_id
WHERE r.urn = $1
GROUP BY rev.id
`

type ListResourceRevisionsRow struct {
	ID          int64
	Reason      string
	CreatedAt   pgtype.Timestamptz
	ResourceID  int64
	SpecConfigs []byte
	CreatedBy   string
	Tags        []string
}

func (q *Queries) ListResourceRevisions(ctx context.Context, urn string) ([]ListResourceRevisionsRow, error) {
	rows, err := q.db.Query(ctx, listResourceRevisions, urn)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListResourceRevisionsRow
	for rows.Next() {
		var i ListResourceRevisionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Reason,
			&i.CreatedAt,
			&i.ResourceID,
			&i.SpecConfigs,
			&i.CreatedBy,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listResourceURNsByFilter = `-- name: ListResourceURNsByFilter :many
SELECT r.id, r.urn, r.kind, r.name, r.project, r.created_at, r.updated_at, r.spec_configs, r.state_status, r.state_output, r.state_module_data, r.state_next_sync, r.state_sync_result, r.created_by, r.updated_by,
       array_agg(rt.tag)::text[] AS tags
FROM resources r
         JOIN resource_tags rt ON r.id = rt.resource_id
WHERE ($1::text IS NULL OR r.project = $1)
  AND ($2::text IS NULL OR r.kind = $2)
GROUP BY r.id
`

type ListResourceURNsByFilterParams struct {
	Project pgtype.Text
	Kind    pgtype.Text
}

type ListResourceURNsByFilterRow struct {
	ID              int64
	Urn             string
	Kind            string
	Name            string
	Project         string
	CreatedAt       pgtype.Timestamptz
	UpdatedAt       pgtype.Timestamptz
	SpecConfigs     []byte
	StateStatus     string
	StateOutput     []byte
	StateModuleData []byte
	StateNextSync   pgtype.Timestamptz
	StateSyncResult []byte
	CreatedBy       string
	UpdatedBy       string
	Tags            []string
}

func (q *Queries) ListResourceURNsByFilter(ctx context.Context, arg ListResourceURNsByFilterParams) ([]ListResourceURNsByFilterRow, error) {
	rows, err := q.db.Query(ctx, listResourceURNsByFilter, arg.Project, arg.Kind)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListResourceURNsByFilterRow
	for rows.Next() {
		var i ListResourceURNsByFilterRow
		if err := rows.Scan(
			&i.ID,
			&i.Urn,
			&i.Kind,
			&i.Name,
			&i.Project,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SpecConfigs,
			&i.StateStatus,
			&i.StateOutput,
			&i.StateModuleData,
			&i.StateNextSync,
			&i.StateSyncResult,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateModule = `-- name: UpdateModule :exec
UPDATE modules
SET configs    = $2,
    updated_at = current_timestamp
WHERE urn = $1
`

type UpdateModuleParams struct {
	Urn     string
	Configs []byte
}

func (q *Queries) UpdateModule(ctx context.Context, arg UpdateModuleParams) error {
	_, err := q.db.Exec(ctx, updateModule, arg.Urn, arg.Configs)
	return err
}

const updateResource = `-- name: UpdateResource :one
UPDATE resources
SET updated_at        = current_timestamp,
    updated_by        = $2,
    spec_configs      = $3,
    state_status      = $4,
    state_output      = $5,
    state_module_data = $6,
    state_next_sync   = $7,
    state_sync_result = $8
WHERE urn = $1
RETURNING id
`

type UpdateResourceParams struct {
	Urn             string
	UpdatedBy       string
	SpecConfigs     []byte
	StateStatus     string
	StateOutput     []byte
	StateModuleData []byte
	StateNextSync   pgtype.Timestamptz
	StateSyncResult []byte
}

func (q *Queries) UpdateResource(ctx context.Context, arg UpdateResourceParams) (int64, error) {
	row := q.db.QueryRow(ctx, updateResource,
		arg.Urn,
		arg.UpdatedBy,
		arg.SpecConfigs,
		arg.StateStatus,
		arg.StateOutput,
		arg.StateModuleData,
		arg.StateNextSync,
		arg.StateSyncResult,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}
